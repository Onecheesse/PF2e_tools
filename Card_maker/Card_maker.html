<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gener√°tor TTRPG Karet</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Libraries for PDF generation and Canvas capture -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <!-- NOV√â: Knihovna pro Drag & Drop ≈ôazen√≠ atribut≈Ø -->
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
    <style>
        /* Pro tisk se bude pou≈æ√≠vat Canvas s vysok√Ωm rozli≈°en√≠m */
        #printCanvas {
            border: 1px dashed #a0a0a0;
            /* Nastaven√© rozmƒõry pro n√°hled, budou p≈ôeps√°ny JS */
            width: 250px; 
            height: 350px;
            cursor: pointer; /* Zvƒõt≈°en√≠ n√°hledu */
        }

        /* Skryje se defaultnƒõ, pro tisk se vytvo≈ô√≠ v JS */
        #hiddenCanvas {
            display: none;
        }

        /* Naƒç√≠tac√≠ indik√°tor */
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            border-radius: 0.75rem;
            z-index: 10;
        }
        
        /* DARK MODE styly pro p≈ôetahovateln√© prvky */
        .attribute-row {
            align-items: center;
            cursor: grab; /* Naznaƒçen√≠, ≈æe je to p≈ôetahovateln√© */
            padding: 4px 0;
        }

        .dark .attribute-row input, 
        .dark #cardDescription,
        .dark #cardDescriptionCz,
        .dark #jsonInput,
        .dark select {
            background-color: #374151; /* gray-700 */
            border-color: #4b5563; /* gray-600 */
            color: #f3f4f6; /* gray-100 */
        }
        
        .dark #itemImagePreview {
            background-color: #374151;
            color: #d1d5db;
        }

        /* Styl pro mod√°ln√≠ okno */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            max-width: 90%;
            max-height: 90%;
            overflow: auto;
            background: #fff;
            padding: 10px;
            border-radius: 0.75rem;
            position: relative;
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen p-4 md:p-8 font-sans dark:bg-gray-900">

<div class="max-w-7xl mx-auto">
    
    <div class="flex justify-between items-center mb-6">
        <!-- NOV√â: P≈ôep√≠naƒç Dark Mode (Lev√Ω roh) -->
        <button id="themeToggle" onclick="toggleTheme()" class="p-2 rounded-full bg-gray-200 text-gray-700 dark:bg-gray-700 dark:text-yellow-400 hover:bg-gray-300 dark:hover:bg-gray-600 transition">
            <!-- Ikona pro svƒõtl√Ω re≈æim (Mƒõs√≠c) -->
            <svg id="moonIcon" class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 12.003 12.003 0 0012 21a12.003 12.003 0 008.354-5.646z"></path></svg>
            <!-- Ikona pro tmav√Ω re≈æim (Slunce) -->
            <svg id="sunIcon" class="w-6 h-6 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path></svg>
        </button>

        <!-- Verze aplikace V_0.14 -->
        <p class="text-xs text-gray-400 text-right">V_0.14</p>
    </div>

    <h1 class="text-4xl font-extrabold text-gray-900 dark:text-white mb-6 text-center">
        TTRPG Gener√°tor Karet
    </h1>
    <p class="text-center text-gray-500 dark:text-gray-400 mb-8">
        Vytvo≈ôte si fyzick√© karty s p≈ôesn√Ωmi rozmƒõry 63mm x 88mm.
    </p>

    <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
        <!-- Panel pro zad√°v√°n√≠ informac√≠ (Lev√° strana) -->
        <div class="lg:col-span-2 bg-white dark:bg-gray-800 p-6 rounded-xl shadow-lg h-full relative">
            
            <!-- P≈ôekryt√≠ pro naƒç√≠t√°n√≠ -->
            <div id="loadingOverlay" class="loading-overlay hidden">
                <svg class="animate-spin -ml-1 mr-3 h-10 w-10 text-indigo-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                <p class="mt-4 text-lg font-semibold text-indigo-700">Analyzuji obr√°zky...</p>
                <p class="text-sm text-gray-500">M≈Ø≈æe to trvat nƒõkolik sekund.</p>
            </div>

            <h2 class="text-2xl font-bold mb-4 border-b pb-2 text-gray-700 dark:text-gray-200 dark:border-gray-700">1. Zad√°n√≠ informac√≠ o kartƒõ</h2>

            <!-- N√°zev a P≈ôeklad -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <div>
                    <label for="cardTitle" class="block text-sm font-medium text-gray-700 dark:text-gray-300">N√°zev (Origin√°ln√≠ jazyk)</label>
                    <input type="text" id="cardTitle" value="Sickle (Srp)" class="mt-1 block w-full border-gray-300 dark:border-gray-600 rounded-lg shadow-sm focus:ring-indigo-500 focus:border-indigo-500 p-2 border bg-white dark:bg-gray-700 dark:text-white">
                </div>
                <div>
                    <label for="cardTranslation" class="block text-sm font-medium text-gray-700 dark:text-gray-300">P≈ôeklad (Volitelnƒõ, do CZ v z√°vorce)</label>
                    <input type="text" id="cardTranslation" value="Srp" class="mt-1 block w-full border-gray-300 dark:border-gray-600 rounded-lg shadow-sm focus:ring-indigo-500 focus:border-indigo-500 p-2 border bg-white dark:bg-gray-700 dark:text-white">
                </div>
            </div>

            <!-- NOV√â: Typ p≈ôedmƒõtu a Templaty -->
            <div class="mb-6 border-b pb-4 dark:border-gray-700">
                <label for="cardType" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Typ p≈ôedmƒõtu (Zobraz√≠ se v rohu karty)</label>
                <div class="flex space-x-3 mb-3">
                    <select id="cardType" class="flex-grow border-gray-300 dark:border-gray-600 rounded-lg shadow-sm focus:ring-indigo-500 focus:border-indigo-500 p-2 border bg-white dark:bg-gray-700 dark:text-white" onchange="updatePreview()">
                        <option value="ITEM">P≈ôedmƒõt (Item)</option>
                        <option value="WEAPON">Zbra≈à (Weapon)</option>
                        <option value="SPELL">Kouzlo (Spell)</option>
                        <option value="CONSUMABLE">Spot≈ôebn√≠ p≈ôedmƒõt (Consumable)</option>
                        <option value="EQUIPMENT">Vybaven√≠ (Equipment)</option>
                        <option value="OTHER">Ostatn√≠ (Other)</option>
                    </select>
                    <button onclick="applyTemplate()" class="bg-indigo-200 text-indigo-800 text-sm font-semibold px-4 py-2 rounded-lg hover:bg-indigo-300 transition duration-150 dark:bg-indigo-700 dark:text-indigo-100 dark:hover:bg-indigo-600">
                        Pou≈æ√≠t Template
                    </button>
                </div>
            </div>
            
            <!-- Obr√°zek pro Anal√Ωzu (Screenshot) -->
            <h3 class="text-xl font-semibold mb-3 text-gray-700 dark:text-gray-200">2. Anal√Ωza Screenshot≈Ø</h3>
            <div id="dropZone" class="mb-4 p-4 border-2 border-dashed border-indigo-300 rounded-lg bg-indigo-50 dark:bg-indigo-900/30 text-center cursor-pointer hover:border-indigo-500 transition duration-150"
                 ondragover="event.preventDefault()"
                 ondrop="handleImageDrop(event)"
                 title="Vlo≈æte sem obr√°zek ze schr√°nky (Ctrl+V) nebo p≈ôet√°hnƒõte soubor.">
                
                <p class="text-indigo-700 dark:text-indigo-300 font-semibold mb-2">Vlo≈æte JEDEN nebo V√çCE screenshot≈Ø pro ANAL√ùZU (Ctrl+V) nebo soubor</p>
                
                <div class="flex flex-col md:flex-row items-center justify-center space-y-3 md:space-y-0 md:space-x-3">
                    <input type="file" id="analysisImageUpload" accept="image/*" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-100 file:text-indigo-700 hover:file:bg-indigo-200 dark:file:bg-indigo-800 dark:file:text-white dark:hover:file:bg-indigo-700">
                    
                    <button id="analyzeButton" onclick="analyzeScreenshots()" disabled class="w-full md:w-2/3 bg-red-500 text-white font-bold p-3 rounded-lg hover:bg-red-600 transition duration-150 shadow-md disabled:opacity-50 disabled:cursor-not-allowed">
                        Analyzovat V≈°echny Screenshoty
                    </button>
                </div>

                <!-- NOV√â: N√°hled pro vizu√°ln√≠ potvrzen√≠ nahr√°n√≠/vlo≈æen√≠ -->
                <div id="analysisImagePreviewsContainer" class="mt-3 grid grid-cols-2 md:grid-cols-4 gap-3">
                    <!-- Zde se dynamicky vkl√°daj√≠ n√°hledy -->
                </div>
                <div class="mt-3 flex space-x-2 justify-center" id="analysisControls" style="display: none;">
                    <!-- Zmƒõnƒõno: Odebr√°no tlaƒç√≠tko pro Odebrat posledn√≠ -->
                    <button onclick="clearAllScreenshots()" class="bg-gray-500 text-white text-sm px-3 py-1 rounded-lg hover:bg-gray-600">Resetovat v≈°e</button>
                </div>
            </div>

            <!-- NOV√â: Sekce pro JSON vstup -->
            <div class="mb-6 border-b pb-4 dark:border-gray-700">
                 <h3 class="text-xl font-semibold mb-3 text-gray-700 dark:text-gray-200">2b. Naƒç√≠st data z JSON (Alternativa k obr√°zk≈Øm)</h3>
                 <textarea id="jsonInput" rows="4" class="mt-1 block w-full border-gray-300 dark:border-gray-600 rounded-lg shadow-sm focus:ring-yellow-500 focus:border-yellow-500 p-2 border bg-white dark:bg-gray-700 dark:text-white" placeholder="Vlo≈æte JSON data (z extern√≠ho API nebo souboru) ve stejn√©m form√°tu, jak√Ω generuje Gemini API."></textarea>
                 <button onclick="loadJsonData()" class="w-full mt-2 bg-yellow-500 text-white font-bold p-2 rounded-lg hover:bg-yellow-600 transition duration-150 shadow-md">
                     Naƒç√≠st JSON data
                 </button>
                 <p class="text-xs text-gray-500 dark:text-gray-400 mt-1">
                    *Pozn√°mka: P≈ô√≠m√© stahov√°n√≠ z libovoln√© URL nen√≠ kv≈Øli bezpeƒçnostn√≠m omezen√≠m Canvasu mo≈æn√©. Vlo≈æte data v textov√© podobƒõ.
                 </p>
            </div>

            <!-- Vlastn√≠ obr√°zek pro zobrazen√≠ na kartƒõ -->
            <div class="mb-6 border-b pb-4 dark:border-gray-700">
                <label for="itemImageUpload" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Obr√°zek itemu (Zobraz√≠ se na kartƒõ)</label>
                <input type="file" id="itemImageUpload" accept="image/*" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-green-50 file:text-green-700 hover:file:bg-green-100 dark:file:bg-green-700 dark:file:text-white dark:hover:file:bg-green-600">
                <p class="text-xs text-gray-400 dark:text-gray-500 mt-1">Nahrajte o≈ô√≠znut√Ω obr√°zek, kter√Ω se zobraz√≠ na kartƒõ. (Ide√°ln√≠ pomƒõr 1:1)</p>
                <div id="itemImagePreview" class="mt-3 w-32 h-32 bg-gray-100 dark:bg-gray-700 rounded-lg border border-dashed border-gray-400 dark:border-gray-600 flex items-center justify-center text-gray-500 dark:text-gray-400 overflow-hidden text-sm mx-auto">
                    N√°hled itemu
                </div>
            </div>


            <!-- Kl√≠ƒçov√© Atributy (Flexibiln√≠ a se≈ôazen√©) -->
            <h3 class="text-xl font-semibold mb-1 text-gray-700 dark:text-gray-200">3. Kl√≠ƒçov√© Atributy</h3>
            <!-- NOV√Å POZN√ÅMKA K DRAG & DROP -->
            <p class="text-sm text-gray-500 dark:text-gray-400 mb-3">Atributy m≈Ø≈æete p≈ôetahovat (Drag & Drop) pro manu√°ln√≠ zmƒõnu po≈ôad√≠.</p>
            
            <div id="attributesContainer" class="space-y-3 mb-6 p-4 border border-gray-200 dark:border-gray-700 rounded-lg bg-gray-50 dark:bg-gray-700">
                <!-- Poƒç√°teƒçn√≠ atributy -->
                <div class="flex space-x-2 attribute-row">
                    <input type="text" value="Cena" class="attr-key w-1/3 p-2 border border-gray-300 rounded-lg bg-white dark:bg-gray-700 dark:border-gray-600 dark:text-white" placeholder="Atribut (nap≈ô. Level)">
                    <input type="text" value="2 sp" class="attr-value w-2/3 p-2 border border-gray-300 rounded-lg bg-white dark:bg-gray-700 dark:border-gray-600 dark:text-white" placeholder="Hodnota (nap≈ô. 50 gp)">
                    <!-- NOV√â: Vol√° manageAttributes pro odebr√°n√≠ -->
                    <button type="button" onclick="manageAttributes('remove', this)" class="p-2 flex-shrink-0 text-red-500 hover:bg-red-100 dark:hover:bg-red-800/50 rounded-lg flex items-center justify-center">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                    </button>
                </div>
                <div class="flex space-x-2 attribute-row">
                    <input type="text" value="Typ" class="attr-key w-1/3 p-2 border border-gray-300 rounded-lg bg-white dark:bg-gray-700 dark:border-gray-600 dark:text-white" placeholder="Atribut (nap≈ô. Cena)">
                    <input type="text" value="Melee, Category Simple, Group Knife" class="attr-value w-2/3 p-2 border border-gray-300 rounded-lg bg-white dark:bg-gray-700 dark:border-gray-600 dark:text-white" placeholder="Hodnota (nap≈ô. 50 gp)">
                    <button type="button" onclick="manageAttributes('remove', this)" class="p-2 flex-shrink-0 text-red-500 hover:bg-red-100 dark:hover:bg-red-800/50 rounded-lg flex items-center justify-center">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                    </button>
                </div>
                <div class="flex space-x-2 attribute-row">
                    <input type="text" value="Po≈°kozen√≠" class="attr-key w-1/3 p-2 border border-gray-300 rounded-lg bg-white dark:bg-gray-700 dark:border-gray-600 dark:text-white" placeholder="Atribut (nap≈ô. Typ)">
                    <input type="text" value="1d6 persistent bleed damage" class="attr-value w-2/3 p-2 border border-gray-300 rounded-lg bg-white dark:bg-gray-700 dark:border-gray-600 dark:text-white" placeholder="Hodnota (nap≈ô. 1d8)">
                    <button type="button" onclick="manageAttributes('remove', this)" class="p-2 flex-shrink-0 text-red-500 hover:bg-red-100 dark:hover:bg-red-800/50 rounded-lg flex items-center justify-center">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                    </button>
                </div>
            </div>
            <!-- NOV√â: Vol√° manageAttributes pro p≈ôid√°n√≠ -->
            <button onclick="manageAttributes('add')" class="w-full bg-indigo-500 text-white p-2 rounded-lg hover:bg-indigo-600 transition duration-150 shadow-md">
                + P≈ôidat Atribut
            </button>

            <!-- Popis (ENG - prim√°rn√≠) -->
            <div class="mt-6 mb-4">
                <label for="cardDescription" class="block text-sm font-medium text-gray-700 dark:text-gray-300">4. Popis Itemu/Kouzla (Origin√°ln√≠ jazyk)</label>
                <textarea id="cardDescription" rows="10" class="mt-1 block w-full border-gray-300 dark:border-gray-600 rounded-lg shadow-sm focus:ring-indigo-500 focus:border-indigo-500 p-2 border bg-white dark:bg-gray-700 dark:text-white">Popis: Originally a farming tool used for reaping grain, this one-handed weapon has a short wooden handle ending in a curved blade, sometimes sharpened on both sides. Zde jsou specifick√© vlastnosti:

**TRAITS**
*Agile*: The multiple attack penalty you take with this weapon on the second attack on your turn is -4 instead of -5, and -8 instead of -10 on the third and subsequent attacks in the turn.
*Finesse*: You can use your Dexterity modifier instead of your Strength modifier on attack rolls using this melee weapon. You still calculate damage using Strength.
*Trip*: You can use this weapon to Trip with the Athletics skill even if you don't have a free hand. This uses the weapon's reach (if different from your own) and adds the weapon's item bonus to attack rolls as an item bonus to the Athletics check. If you critically fail a check to Trip using the weapon, you can drop the weapon to take the effects of a basic failure instead of a critical failure.

**CRITICAL SPECIALIZATION EFFECT**
(Source: Core Rulebook pg. 283-4) Certain feats, class features, weapon runes, and other effects can grant you additional benefits when you make a Strike with certain weapons and get a critical success. This is called a critical specialization effect. The exact effect depends on which weapon group your weapon belongs to.</textarea>
            </div>
            
             <!-- NOV√â: Popis (CZ - p≈ôelo≈æen√Ω) -->
            <div class="mb-6">
                <label for="cardDescriptionCz" class="block text-sm font-medium text-gray-700 dark:text-gray-300">4b. Popis Itemu/Kouzla (P≈ôelo≈æen√Ω do CZ)</label>
                <textarea id="cardDescriptionCz" rows="10" class="mt-1 block w-full border-gray-300 dark:border-gray-600 rounded-lg shadow-sm focus:ring-indigo-500 focus:border-indigo-500 p-2 border bg-white dark:bg-gray-700 dark:text-white" placeholder="Sem se automaticky vygeneruje p≈ôelo≈æen√Ω popis. M≈Ø≈æete jej upravit.">Popis: P≈Øvodnƒõ farm√°≈ôsk√Ω n√°stroj pou≈æ√≠van√Ω ke ≈ænut√≠ obil√≠, tato jednoruƒçn√≠ zbra≈à m√° kr√°tkou d≈ôevƒõnou rukoje≈• konƒç√≠c√≠ zak≈ôivenou ƒçepel√≠, nƒõkdy nabrou≈°enou z obou stran. Zde jsou specifick√© vlastnosti:

**TRAITS**
*Agile*: Postih pro v√≠cen√°sobn√Ω √∫tok, kter√Ω obdr≈æ√≠te s touto zbran√≠ na druh√Ω √∫tok ve va≈°em tahu, je -4 m√≠sto -5, a -8 m√≠sto -10 na t≈ôet√≠ a n√°sleduj√≠c√≠ √∫toky v tahu.
*Finesse*: M≈Ø≈æete pou≈æ√≠t sv≈Øj modifik√°tor Obratnosti m√≠sto modifik√°toru S√≠ly na hody √∫tokem s touto zbran√≠ na bl√≠zko. Po≈°kozen√≠ st√°le poƒç√≠t√°te se S√≠lou.
*Trip*: M≈Ø≈æete pou≈æ√≠t tuto zbra≈à k Podra≈æen√≠ (Trip) dovednost√≠ Atletika, i kdy≈æ nem√°te volnou ruku. Pou≈æ√≠v√° dosah zbranƒõ (pokud se li≈°√≠ od va≈°eho) a p≈ôid√°v√° bonus k hodu √∫tokem zbranƒõ jako bonus k testu Atletiky. Pokud kriticky sel≈æete v testu Podra≈æen√≠ pomoc√≠ zbranƒõ, m≈Ø≈æete ji upustit a m√≠sto kritick√©ho selh√°n√≠ obdr≈æet z√°kladn√≠ selh√°n√≠.

**CRITICAL SPECIALIZATION EFFECT**
(Source: Core Rulebook pg. 283-4) Nƒõkter√© Featy, t≈ô√≠dn√≠ vlastnosti, runy na zbran√≠ch a dal≈°√≠ efekty v√°m mohou udƒõlit dodateƒçn√© v√Ωhody, kdy≈æ provedete √öder (Strike) s urƒçit√Ωmi zbranƒõmi a dos√°hnete kritick√©ho √∫spƒõchu. Tomu se ≈ô√≠k√° efekt kritick√© specializace. P≈ôesn√Ω efekt z√°vis√≠ na skupinƒõ zbranƒõ, do kter√© va≈°e zbra≈à pat≈ô√≠.</textarea>
            </div>


            <button onclick="updatePreview()" class="w-full bg-green-500 text-white font-bold p-3 rounded-lg hover:bg-green-600 transition duration-150 shadow-md transform hover:scale-[1.01]">
                Aktualizovat N√°hled Karty
            </button>
        </div>

        <!-- N√°hled Karty (Prav√° strana) -->
        <div class="lg:col-span-1 bg-white dark:bg-gray-800 p-6 rounded-xl shadow-lg flex flex-col items-center sticky top-4 h-fit">
            <h2 class="text-2xl font-bold mb-4 border-b pb-2 text-gray-700 dark:text-gray-200 dark:border-gray-700 w-full text-center">N√°hled Karty</h2>
            
            <div class="flex space-x-2 mb-4">
                 <button id="langEng" onclick="setPrintLanguage('ENG')" class="px-3 py-1 rounded-lg font-bold bg-indigo-500 text-white hover:bg-indigo-600 transition duration-150">
                    ENG
                 </button>
                 <button id="langCz" onclick="setPrintLanguage('CZ')" class="px-3 py-1 rounded-lg font-bold bg-gray-200 text-gray-700 hover:bg-gray-300 dark:bg-gray-700 dark:text-gray-200 dark:hover:bg-gray-600 transition duration-150">
                    CZ
                 </button>
            </div>

            <div class="mb-6 overflow-x-auto w-full">
                <!-- HTML Canvas pro n√°hled a generov√°n√≠ PDF -->
                <!-- D≈ÆLE≈ΩIT√â: Canvas z≈Øst√°v√° b√≠l√Ω, tmav√Ω re≈æim neovliv≈àuje v√Ωstup tisku/n√°hledu -->
                <canvas id="printCanvas" width="744" height="1038" class="shadow-xl rounded-lg mx-auto" onclick="showZoomModal()"></canvas>
            </div>

            <div class="flex space-x-4 w-full">
                <button onclick="exportJSON()" class="w-1/2 bg-gray-600 text-white font-bold p-3 rounded-lg hover:bg-gray-700 transition duration-150 shadow-lg mt-4">
                    <div class="flex items-center justify-center">
                        <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-4m0 0l-4-4m4 4H4"></path></svg>
                        St√°hnout JSON
                    </div>
                </button>
                <button onclick="exportPDF()" class="w-1/2 bg-black text-white font-bold p-3 rounded-lg hover:bg-gray-800 transition duration-150 shadow-lg mt-4">
                    <div class="flex items-center justify-center">
                        <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg>
                        St√°hnout PDF
                    </div>
                </button>
            </div>
            <p class="text-xs text-gray-500 dark:text-gray-400 mt-2 text-center">PDF soubor bude obsahovat p≈ôesn√© rozmƒõry pro tisk a slo≈æen√≠ (p≈ô√≠padn√© roz≈°√≠≈ôen√≠).</p>
        </div>
    </div>

    <!-- NOV√Å SEKCE PRO API KL√çƒå -->
    <div class="mt-8 bg-white dark:bg-gray-800 p-6 rounded-xl shadow-lg">
        <h2 class="text-2xl font-bold mb-4 border-b pb-2 text-gray-700 dark:text-gray-200 dark:border-gray-700">5. Nastaven√≠ Gemini API</h2>
        <div class="flex flex-col md:flex-row space-y-4 md:space-y-0 md:space-x-4 items-center">
            <div class="flex-grow w-full">
                <label for="geminiApiKey" class="block text-sm font-medium text-gray-700 dark:text-gray-300">
                    V√°≈° Gemini API kl√≠ƒç 
                    <span id="apiKeyHint" class="text-indigo-600 font-normal text-xs">(Pou≈æ√≠v√° se lok√°ln√≠ kl√≠ƒç Canvasu. Pro lok√°ln√≠ spu≈°tƒõn√≠ jej zadejte zde.)</span>
                </label>
                <input type="text" id="geminiApiKey" class="mt-1 block w-full border-gray-300 dark:border-gray-600 rounded-lg shadow-sm focus:ring-indigo-500 focus:border-indigo-500 p-2 border bg-white dark:bg-gray-700 dark:text-white" placeholder="Zadejte kl√≠ƒç pro aktivaci anal√Ωzy obr√°zk≈Ø">
            </div>
            <p class="text-sm text-gray-500 dark:text-gray-400 w-full md:w-auto flex-shrink-0">
                Kl√≠ƒç z√≠sk√°te zdarma zde: 
                <a href="https://aistudio.google.com/api-keys" target="_blank" class="text-indigo-600 hover:text-indigo-800 dark:text-indigo-400 dark:hover:text-indigo-300 font-semibold underline">Google AI Studio</a>
            </p>
        </div>
    </div>
</div>

<canvas id="hiddenCanvas" width="744" height="1038"></canvas>

<!-- NOV√â: Mod√°ln√≠ okno pro zoomov√°n√≠ -->
<div id="zoomModal" class="modal hidden">
    <div class="modal-content bg-gray-900 shadow-2xl p-4 relative">
        <button onclick="closeZoomModal()" class="absolute top-2 right-2 text-white text-3xl hover:text-red-400 z-50">
            &times;
        </button>
        <h3 class="text-xl text-white mb-2 border-b pb-1">Detailn√≠ n√°hled karty (Zoom: Ctrl + koleƒçko)</h3>
        <canvas id="zoomCanvas" class="bg-white rounded-lg block max-w-full max-h-[calc(100vh-100px)] mx-auto"></canvas>
    </div>
</div>


<script>
    // --- KONSTANTY PRO KARTU ---
    const CARD_W_MM = 63;
    const CARD_H_MM = 88;
    const DPI = 300;
    const PX_PER_MM = DPI / 25.4;
    const BASE_CARD_W = Math.round(CARD_W_MM * PX_PER_MM); // ~744 px
    const BASE_CARD_H = Math.round(CARD_H_MM * PX_PER_MM); // ~1038 px

    const PADDING = 30; // Vnit≈ôn√≠ padding karty v pixelech
    const IMAGE_SIZE = 300; // Velikost ƒçtvercov√©ho obr√°zku itemu v pixelech
    
    // Glob√°ln√≠ Canvas API kl√≠ƒç (pokud existuje) - Zaji≈°tƒõn√≠, ≈æe se pou≈æ√≠v√° lok√°ln√≠ kl√≠ƒç, pokud je definov√°n
    const CANVAS_API_KEY = typeof __gemini_api_key !== 'undefined' ? __gemini_api_key : '';

    // API kl√≠ƒç se bude naƒç√≠tat dynamicky z inputu nebo glob√°ln√≠ promƒõnn√©
    const GEMINI_API_BASE_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=`;
    
    let currentCardData = {};
    let itemImageObject = null;
    let analysisImagesBase64 = []; // Pole pro ukl√°d√°n√≠ Base64 dat z v√≠ce obr√°zk≈Ø
    let printLanguage = 'ENG'; // NOV√â: V√Ωchoz√≠ jazyk pro tisk
    
    const canvas = document.getElementById('printCanvas');
    const ctx = canvas.getContext('2d');
    const hiddenCanvas = document.getElementById('hiddenCanvas');
    const hiddenCtx = hiddenCanvas.getContext('2d');
    const analyzeButton = document.getElementById('analyzeButton');
    const loadingOverlay = document.getElementById('loadingOverlay');
    const itemImagePreview = document.getElementById('itemImagePreview');
    const analysisImageUpload = document.getElementById('analysisImageUpload');
    const analysisImagePreviewsContainer = document.getElementById('analysisImagePreviewsContainer');
    const analysisControls = document.getElementById('analysisControls');
    const geminiApiKeyInput = document.getElementById('geminiApiKey');
    const cardTypeInput = document.getElementById('cardType');
    const attributesContainer = document.getElementById('attributesContainer');
    const jsonInput = document.getElementById('jsonInput'); // NOV√â: pro JSON vstup
    const body = document.body;
    const moonIcon = document.getElementById('moonIcon');
    const sunIcon = document.getElementById('sunIcon');
    const langEngButton = document.getElementById('langEng');
    const langCzButton = document.getElementById('langCz');


    // Po≈ôad√≠ pro automatick√© ≈ôazen√≠ atribut≈Ø
    const ATTRIBUTE_ORDER = [
        "LEVEL", "√öROVE≈á",
        "PRICE", "CENA",
        "TYPE", "TYP", "DICE", "KOSTKY", "PO≈†KOZEN√ç", "DAMAGE",
        "TAGS",
        "RARITY", "VZ√ÅCNOST"
    ];

    // --- TEMPLATY A DATA PRO TYPY KARET ---
    
    // NOV√â: Mapov√°n√≠ emoji na typy karet
    const TYPE_EMOJI = {
        'ITEM': 'üì¶',       // Item - krabice
        'WEAPON': '‚öîÔ∏è',     // Weapon - zk≈ô√≠≈æen√© meƒçe
        'SPELL': '‚ú®',      // Spell - jiskry
        'CONSUMABLE': 'üß™', // Consumable - lahviƒçka/lektvar
        'EQUIPMENT': 'üõ°Ô∏è',  // Equipment - ≈°t√≠t
        'OTHER': 'üìú'       // Other - svitek
    };

    const CARD_TEMPLATES = {
        'ITEM': {
            title: 'Hladov√Ω n√°ramek', translation: 'Hungry Armlet',
            description: 'Tento n√°ramek z nezn√°m√©ho kovu pulzuje slab√Ωm teplem. C√≠t√≠te, jak je hladov√Ω. Kdy≈æ ho m√°te na ruce, obƒças usly≈°√≠te tich√© ≈°ept√°n√≠. \\n\\n**Aktivace**: Po≈æije se, kdy≈æ dostanete zranƒõn√≠. Sn√≠≈æ√≠ o 1 obdr≈æen√© po≈°kozen√≠. Po 3 pou≈æit√≠ch se rozpadne.',
            descriptionCz: 'Tento n√°ramek z nezn√°m√©ho kovu pulzuje slab√Ωm teplem. C√≠t√≠te, jak je hladov√Ω. Kdy≈æ ho m√°te na ruce, obƒças usly≈°√≠te tich√© ≈°ept√°n√≠. \\n\\n**Aktivace**: Spot≈ôebuje se, kdy≈æ obdr≈æ√≠te po≈°kozen√≠. Sn√≠≈æ√≠ o 1 obdr≈æen√© po≈°kozen√≠. Po 3 pou≈æit√≠ch se rozpadne.',
            attributes: [
                { key: 'Cena', value: '10 gp' },
                { key: 'Vz√°cnost', value: 'Common' }
            ]
        },
        'WEAPON': {
            title: 'Otr√°ven√Ω D√Ωka', translation: 'Poisoned Dagger',
            description: 'ƒåepel je pokryta pomalu p≈Øsob√≠c√≠m jedem. Ka≈æd√© zasa≈æen√≠ m√° ≈°anci aplikovat na c√≠l jed. \\n\\n**Jed (DC 13)**: P≈ôi selh√°n√≠ utrp√≠ c√≠l 1d4 jedovat√©ho po≈°kozen√≠ na zaƒç√°tku sv√©ho tahu. Trv√° 3 kola.',
            descriptionCz: 'ƒåepel je pokryta pomalu p≈Øsob√≠c√≠m jedem. Ka≈æd√© zasa≈æen√≠ m√° ≈°anci aplikovat na c√≠l jed. \\n\\n**Jed (DC 13)**: P≈ôi selh√°n√≠ utrp√≠ c√≠l 1k4 jedovat√©ho po≈°kozen√≠ na zaƒç√°tku sv√©ho tahu. Trv√° 3 kola.',
            attributes: [
                { key: 'Cena', value: '30 gp' },
                { key: 'Po≈°kozen√≠', value: '1d4 piercing + Poison' },
                { key: 'Typ', value: 'Lehk√° zbra≈à, Finesse' }
            ]
        },
        'SPELL': {
            title: 'Ohniv√° Zeƒè', translation: 'Wall of Fire',
            description: 'Vytvo≈ô√≠ nepr≈Øchoz√≠ stƒõnu plamen≈Ø, kter√° spaluje ka≈æd√©ho, kdo se k n√≠ p≈ôibl√≠≈æ√≠. \\n\\n**Efekt**: Kreatura, kter√° zaƒçne sv≈Øj tah 10 stop od stƒõny, utrp√≠ 2k6 ohniv√©ho po≈°kozen√≠. Kreatura, kter√° projde stƒõnou, utrp√≠ 5k6 ohniv√©ho po≈°kozen√≠.',
            descriptionCz: 'Vytvo≈ô√≠ nepr≈Øchoz√≠ stƒõnu plamen≈Ø, kter√° spaluje ka≈æd√©ho, kdo se k n√≠ p≈ôibl√≠≈æ√≠. \\n\\n**Efekt**: Stvo≈ôen√≠, kter√© zaƒçne sv≈Øj tah 10 stop od stƒõny, utrp√≠ 2k6 ohniv√©ho po≈°kozen√≠. Stvo≈ôen√≠, kter√© projde stƒõnou, utrp√≠ 5k6 ohniv√©ho po≈°kozen√≠.',
            attributes: [
                { key: 'Level', value: '4' },
                { key: 'Akce', value: '2' },
                { key: 'Dosah', value: '120 ft' }
            ]
        },
        'CONSUMABLE': {
            title: 'L√©ƒçiv√Ω lektvar', translation: 'Healing Potion',
            description: 'Klasick√Ω lektvar, kter√Ω rychle l√©ƒç√≠ r√°ny. \\n\\n**Pou≈æit√≠**: Vypit√≠ zabere 1 akci. Obnov√≠ 2d4 + 2 ≈æivoty.',
            descriptionCz: 'Klasick√Ω lektvar, kter√Ω rychle l√©ƒç√≠ zranƒõn√≠. \\n\\n**Pou≈æit√≠**: Vypit√≠ zabere 1 akci. Obnov√≠ 2k4 + 2 ≈æivoty.',
            attributes: [
                { key: 'Cena', value: '50 gp' },
                { key: 'D√°vky', value: '1' }
            ]
        },
        'EQUIPMENT': {
            title: 'Krou≈ækov√° zbroj', translation: 'Chainmail',
            description: 'Standardn√≠ krou≈ækov√° zbroj poskytuje solidn√≠ ochranu. Je hluƒçn√°, ale spolehliv√°.',
            descriptionCz: 'Standardn√≠ krou≈ækov√° zbroj poskytuje spolehlivou ochranu. Je hluƒçn√°, ale efektivn√≠.',
            attributes: [
                { key: 'Cena', value: '50 gp' },
                { key: 'AC Bonus', value: '+4' },
                { key: 'V√°ha', value: 'Tƒõ≈æk√°' }
            ]
        },
        'OTHER': {
            title: 'Mapa starovƒõk√© krypty', translation: 'Ancient Crypt Map',
            description: 'Za≈°ifrovan√° mapa na kusu k≈Ø≈æe. Ukazuje cestu k zapomenut√© hrobce. Vy≈æaduje √∫spƒõ≈°n√Ω test Dovednosti (Investigation) DC 20 k rozlu≈°tƒõn√≠.',
            descriptionCz: 'Za≈°ifrovan√° mapa na kusu k≈Ø≈æe. Ukazuje cestu k zapomenut√© hrobce. Vy≈æaduje √∫spƒõ≈°n√Ω test Dovednosti (Vy≈°et≈ôov√°n√≠) Obt√≠≈ænosti 20 k rozlu≈°tƒõn√≠.',
            attributes: [
                { key: 'Vz√°cnost', value: 'Unique' },
                { key: 'Hodnota', value: 'N/A' }
            ]
        }
    };
    
    // --- FUNKCE PRO DARK MODE ---
    
    window.toggleTheme = function() {
        if (body.classList.contains('dark')) {
            body.classList.remove('dark');
            localStorage.setItem('theme', 'light');
            // Zaji≈°tƒõn√≠ spr√°vn√© aktualizace ikon
            moonIcon.classList.remove('hidden');
            sunIcon.classList.add('hidden');
        } else {
            body.classList.add('dark');
            localStorage.setItem('theme', 'dark');
            // Zaji≈°tƒõn√≠ spr√°vn√© aktualizace ikon
            moonIcon.classList.add('hidden');
            sunIcon.classList.remove('hidden');
        }
        // updateThemeIcons(); // Tato funkce je vol√°na uvnit≈ô, ale pro jistotu ji nech√°me n√≠≈æe
    }
    
    function updateThemeIcons() {
        if (body.classList.contains('dark')) {
            moonIcon.classList.add('hidden');
            sunIcon.classList.remove('hidden');
        } else {
            moonIcon.classList.remove('hidden');
            sunIcon.classList.add('hidden');
        }
    }

    // --- FUNKCE PRO JAZYK TISKU ---
    window.setPrintLanguage = function(lang) {
        printLanguage = lang;
        
        // VYLEP≈†EN√Å INDIKACE: Resetov√°n√≠ a nastaven√≠ t≈ô√≠d pro aktivn√≠ tlaƒç√≠tko
        
        // 1. Reset
        const commonClasses = ['px-3', 'py-1', 'rounded-lg', 'font-bold', 'transition', 'duration-150'];
        const inactiveClasses = ['bg-gray-200', 'text-gray-700', 'hover:bg-gray-300', 'dark:bg-gray-700', 'dark:text-gray-200', 'dark:hover:bg-gray-600'];
        const activeClasses = ['bg-indigo-500', 'text-white', 'hover:bg-indigo-600', 'dark:bg-indigo-600', 'dark:hover:bg-indigo-700'];

        const setClasses = (btn, isActive) => {
            // Odebrat v≈°echny aktivn√≠ t≈ô√≠dy
            btn.classList.remove(...activeClasses);
            // Odebrat v≈°echny neaktivn√≠ t≈ô√≠dy
            btn.classList.remove(...inactiveClasses);
            
            if (isActive) {
                btn.classList.add(...activeClasses);
                btn.classList.remove('bg-gray-200', 'text-gray-700', 'dark:bg-gray-700', 'dark:text-gray-200'); // Jen pro jistotu
            } else {
                btn.classList.add(...inactiveClasses);
            }
        };


        setClasses(langEngButton, lang === 'ENG');
        setClasses(langCzButton, lang === 'CZ');

        updatePreview();
    }

    // --- UTILITY FUNKCE ---
    
    // Funkce pro z√≠sk√°n√≠ aktu√°ln√≠ho kl√≠ƒçe (up≈ôednost≈àuje Canvas kl√≠ƒç)
    function getApiKey() {
        if (CANVAS_API_KEY) {
            return CANVAS_API_KEY;
        }
        return geminiApiKeyInput.value.trim();
    }

    function updateAnalyzeButtonState() {
        // Tlaƒç√≠tko se aktivuje, pokud existuje kl√≠ƒç (Canvas nebo u≈æivatelsk√Ω) A jsou nahr√°ny obr√°zky
        const hasKey = !!getApiKey();
        
        // NOV√Å LOGIKA: Umo≈æn√≠ anal√Ωzu POUZE pokud existuje kl√≠ƒç A jsou nahr√°ny obr√°zky
        analyzeButton.disabled = analysisImagesBase64.length === 0 || !hasKey;
        analysisControls.style.display = analysisImagesBase64.length > 0 ? 'flex' : 'none';
        
        // Zobraz√≠/skryje tip, pokud je kl√≠ƒç z Canvasu aktivn√≠
        const apiKeyHint = document.getElementById('apiKeyHint');
        if (apiKeyHint) {
             apiKeyHint.style.display = CANVAS_API_KEY ? 'inline' : 'none';
             geminiApiKeyInput.disabled = !!CANVAS_API_KEY; // Deaktivuje vstup, pokud je kl√≠ƒç z Canvasu
        }
    }

    function setLoading(isLoading) {
        if (isLoading) {
            loadingOverlay.classList.remove('hidden');
            analyzeButton.disabled = true;
        } else {
            // Stav tlaƒç√≠tka bude ≈ô√≠dit updateAnalyzeButtonState()
            loadingOverlay.classList.add('hidden');
            updateAnalyzeButtonState();
        }
    }

    // --- FUNKCE PRO VKL√ÅD√ÅN√ç A ODEB√çR√ÅN√ç ATRIBUT≈Æ (JEDNOTN√Å FUNKCE) ---
    
    // Nov√° jednotn√° funkce pro spr√°vu atribut≈Ø
    window.manageAttributes = function(action, element = null, key = '', value = '') {
        if (action === 'add') {
            const container = document.getElementById('attributesContainer');
            const newRow = document.createElement('div');
            // P≈ôid√°me handle pro SortableJS
            newRow.className = 'flex space-x-2 attribute-row items-center cursor-grab';
            newRow.innerHTML = `
                <input type="text" value="${key}" class="attr-key w-1/3 p-2 border border-gray-300 rounded-lg bg-white dark:bg-gray-700 dark:border-gray-600 dark:text-white" placeholder="Atribut (nap≈ô. Level)">
                <input type="text" value="${value}" class="attr-value w-2/3 p-2 border border-gray-300 rounded-lg bg-white dark:bg-gray-700 dark:border-gray-600 dark:text-white" placeholder="Hodnota (nap≈ô. 50 gp)">
                <button type="button" onclick="manageAttributes('remove', this)" class="p-2 flex-shrink-0 text-red-500 hover:bg-red-100 dark:hover:bg-red-800/50 rounded-lg flex items-center justify-center">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            `;
            container.appendChild(newRow);
        } else if (action === 'remove' && element) {
            // Odebr√°n√≠ atributu
            const row = element.closest('.attribute-row');
            if (row) {
                row.remove(); 
            }
        }
        updatePreview(); // Aktualizace po jak√©koli akci
    }

    // P≈ôejmenovan√° funkce clearAttributes, kter√° nyn√≠ vol√° manageAttributes pro p≈ôid√°n√≠ pr√°zdn√Ωch ≈ô√°dk≈Ø
    function clearAttributes() {
        document.getElementById('attributesContainer').innerHTML = '';
    }
    
    // --- FUNKCE PRO TEMPLATY ---
    
    window.applyTemplate = function() {
        const type = cardTypeInput.value;
        const template = CARD_TEMPLATES[type];
        
        if (!template) return;

        // 1. Nastaven√≠ textov√Ωch pol√≠
        document.getElementById('cardTitle').value = template.title;
        document.getElementById('cardTranslation').value = template.translation;
        document.getElementById('cardDescription').value = template.description;
        document.getElementById('cardDescriptionCz').value = template.descriptionCz; // NOV√â
        
        // 2. Nastaven√≠ atribut≈Ø
        clearAttributes();
        template.attributes.forEach(attr => {
             manageAttributes('add', null, attr.key, attr.value);
        });

        updatePreview(); // Aktualizovat n√°hled
    }
    
    // NOV√Å FUNKCE: Naƒçten√≠ JSON dat z textov√©ho pole
    window.loadJsonData = function() {
        const jsonText = jsonInput.value.trim();
        if (!jsonText) {
             alert("Pros√≠m, vlo≈æte JSON data.");
             return;
        }

        try {
            const data = JSON.parse(jsonText);
            
            // Z√°kladn√≠ ovƒõ≈ôen√≠ struktury
            if (!data.title || !data.attributes) {
                alert("Neplatn√Ω JSON form√°t. Chyb√≠ 'title' nebo 'attributes'.");
                return;
            }

            // P≈ôed√°n√≠ dat do formul√°≈ôe
            updateFormFields(data);
            alert("Data z JSON √∫spƒõ≈°nƒõ naƒçtena!");
            
        } catch (e) {
            console.error("Chyba p≈ôi parsov√°n√≠ JSON:", e);
            alert("Chyba: Neplatn√Ω JSON form√°t. Zkontrolujte syntaxi.");
        }
    }

    // --- FUNKCE PRO VKL√ÅD√ÅN√ç OBR√ÅZKU (PRO ANAL√ùZU) ---

    // Funkce pro odstranƒõn√≠ jednoho screenshotu podle indexu
    window.removeScreenshot = function(index) {
        if (index >= 0 && index < analysisImagesBase64.length) {
            analysisImagesBase64.splice(index, 1);
            renderAnalysisPreviews();
            updateAnalyzeButtonState();
        }
    }
    
    // Nov√° funkce pro vykreslen√≠ v≈°ech n√°hled≈Ø
    function renderAnalysisPreviews() {
        analysisImagePreviewsContainer.innerHTML = '';
        analysisImagesBase64.forEach((base64Data, index) => {
            const dataUrl = `data:image/png;base64,${base64Data}`;
            
            const imgContainer = document.createElement('div');
            // Zmƒõnƒõno, aby se umo≈ænilo snadn√© odstranƒõn√≠
            imgContainer.className = 'w-full h-20 bg-white border border-gray-300 rounded-lg overflow-hidden relative group'; 
            
            imgContainer.innerHTML = `
                <img src="${dataUrl}" class="object-contain w-full h-full" alt="Screenshot ${index + 1}">
                <button onclick="removeScreenshot(${index})" 
                        class="absolute top-0 right-0 p-1 bg-red-600 text-white rounded-bl-lg opacity-0 group-hover:opacity-100 transition duration-150"
                        title="Odstranit tento screenshot">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            `;
            analysisImagePreviewsContainer.appendChild(imgContainer);
        });
    }

    function addAnalysisImage(dataUrl) {
        const base64Data = dataUrl.split(',')[1];
        analysisImagesBase64.push(base64Data);

        renderAnalysisPreviews();
        updateAnalyzeButtonState();
    }

    // Zpracov√°n√≠ nahr√°n√≠ souboru
    analysisImageUpload.addEventListener('change', function(e) {
        const files = e.target.files;
        if (files.length > 0) {
            Array.from(files).forEach(file => {
                const reader = new FileReader();
                reader.onload = function(event) {
                    addAnalysisImage(event.target.result);
                };
                reader.readAsDataURL(file);
            });
            analysisImageUpload.value = ''; // Reset, aby bylo mo≈æn√© nahr√°t stejn√Ω soubor znovu
        }
    });

    // Zpracov√°n√≠ drag-and-drop pro ANAL√ùZU
    window.handleImageDrop = function(e) {
        e.preventDefault();
        const files = e.dataTransfer.files;
        if (files.length > 0) {
            Array.from(files).forEach(file => {
                if (file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        addAnalysisImage(event.target.result);
                    };
                    reader.readAsDataURL(file);
                }
            });
        }
    }
    
    // Zpracov√°n√≠ Ctrl+V (paste) pro ANAL√ùZU
    document.addEventListener('paste', function(e) {
        const items = e.clipboardData.items;
        for (let i = 0; i < items.length; i++) {
            if (items[i].type.indexOf('image') !== -1) {
                const blob = items[i].getAsFile();
                if (blob.size > 0) { 
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        addAnalysisImage(event.target.result);
                    };
                    reader.readAsDataURL(blob);
                    e.preventDefault();
                    return;
                }
            }
        }
    });

    // Odebr√°n√≠ v≈°ech screenshot≈Ø
    window.clearAllScreenshots = function() {
        analysisImagesBase64 = [];
        analysisImagePreviewsContainer.innerHTML = '';
        updateAnalyzeButtonState();
    };


    // --- FUNKCE PRO VKL√ÅD√ÅN√ç OBR√ÅZKU (PRO ITEM NA KARTƒö) ---
    document.getElementById('itemImageUpload').addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = function(event) {
                const img = new Image();
                img.onload = function() {
                    itemImageObject = img;
                    
                    itemImagePreview.innerHTML = '';
                    itemImagePreview.classList.remove('text-gray-500', 'border-dashed');
                    // Oprava: Zaji≈°tƒõn√≠, ≈æe se do n√°hledu vkl√°d√° img element a m√° spr√°vn√© styly
                    itemImagePreview.appendChild(img);
                    img.style.objectFit = 'contain';
                    img.style.width = '100%';
                    img.style.height = '100%';
                    
                    updatePreview();
                }
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        } else {
            itemImageObject = null;
            itemImagePreview.innerHTML = 'N√°hled itemu';
            itemImagePreview.classList.add('text-gray-500', 'border-dashed');
            updatePreview();
        }
    });

    // --- LOGIKA LLM ANAL√ùZY ---
    
    async function analyzeScreenshots() {
        const apiKey = getApiKey();

        if (!apiKey) {
            // Tohle by se nemƒõlo st√°t, proto≈æe tlaƒç√≠tko je deaktivovan√©, ale pro jistotu
            alert("Pros√≠m, zadejte sv≈Øj Gemini API kl√≠ƒç pro spu≈°tƒõn√≠ anal√Ωzy.");
            return;
        }
        if (analysisImagesBase64.length === 0) {
            alert("Pros√≠m, vlo≈æte alespo≈à jeden screenshot k anal√Ωze.");
            return;
        }

        setLoading(true);

        const responseSchema = {
            type: "OBJECT",
            properties: {
                title: { type: "STRING", description: "Origin√°ln√≠ n√°zev p≈ôedmƒõtu/kouzla z obr√°zku." },
                translation: { type: "STRING", description: "P≈ôeklad n√°zvu do ƒçe≈°tiny, pokud je z≈ôejm√Ω. Jinak nechte pr√°zdn√©." },
                cardType: { type: "STRING", description: "Identifikovan√Ω typ p≈ôedmƒõtu. Mus√≠ b√Ωt jedno z: ITEM, WEAPON, SPELL, CONSUMABLE, EQUIPMENT, OTHER." },
                description: { type: "STRING", description: "Hlavn√≠ popis nebo efekt p≈ôedmƒõtu/kouzla v p≈Øvodn√≠m jazyce. Text by mƒõl b√Ωt souvisl√Ω. Pou≈æijte **dvojit√© hvƒõzdiƒçky** pro tuƒçn√Ω text a *jednoduch√© hvƒõzdiƒçky* pro kurz√≠vu. Pro nov√© odstavce pou≈æijte dvƒõ zalomen√≠ ≈ô√°dku (Enter)." },
                descriptionCz: { type: "STRING", description: "P≈ôesn√Ω p≈ôeklad pole 'description' do ƒçe≈°tiny. Ponechte n√°zvy p≈ôedmƒõt≈Ø, kouzel, levely, skilly a ƒç√≠sla v angliƒçtinƒõ/p≈Øvodn√≠m jazyce. P≈ôelo≈æte pouze popis a souvisl√© texty." },
                attributes: {
                    type: "ARRAY",
                    description: "Pole kl√≠ƒçov√Ωch atribut≈Ø. Nap≈ô√≠klad Level, Cena, Typ, Damage, Vz√°cnost, atd. P≈ôekl√°≈æejte Kl√≠ƒç, ne Hodnotu.",
                    items: {
                        type: "OBJECT",
                        properties: {
                            key: { type: "STRING", description: "N√°zev atributu (nap≈ô. 'Level', 'Cena', 'Kostky')." },
                            value: { type: "STRING", description: "Hodnota atributu (nap≈ô. '3', '150 gp', '1d8 + STR')." }
                        }
                    }
                }
            },
            required: ["title", "cardType", "description", "descriptionCz", "attributes"] // P≈ôid√°no descriptionCz
        };

        const systemPrompt = "Jsi expert na TTRPG data. Analyzuj poskytnut√© screenshoty (m≈Ø≈æe jich b√Ωt v√≠ce, spoj je do jednoho kontextu) a extrahuj ve≈°ker√° relevantn√≠ data do p≈ôesn√©ho JSON form√°tu. D≈ÆLE≈ΩIT√â: Na z√°kladƒõ kontextu detekuj typ p≈ôedmƒõtu (cardType) a vyber z mo≈ænost√≠: ITEM, WEAPON, SPELL, CONSUMABLE, EQUIPMENT, OTHER. Kl√≠ƒçov√© n√°zvy atribut≈Ø (key) p≈ôelo≈æ do ƒçe≈°tiny (Cena, Level, Kostky), Hodnoty (value) ponech v origin√°ln√≠m znƒõn√≠. P≈ôeklad (translation) poskytni pouze pokud je z≈ôejm√Ω, jinak pr√°zdn√Ω ≈ôetƒõzec. V popisu (description) a (descriptionCz) pou≈æij **dvojit√© hvƒõzdiƒçky** pro tuƒçn√Ω text a *jednoduch√© hvƒõzdiƒçky* pro kurz√≠vu. Pro vizu√°ln√≠ oddƒõlen√≠ odstavc≈Ø (nap≈ô. pro odr√°≈æky) pou≈æij dvƒõ zalomen√≠ ≈ô√°dku (\\n\\n). Ujisti se, ≈æe descriptionCz je P≈òESN√ù, SOUVISL√ù A KVALITN√ç p≈ôeklad description, ale zachov√°v√° anglick√© n√°zvy skill≈Ø a ƒç√≠sel, stejnƒõ jako ve tv√©m vzoru.";

        const userQuery = "Analyzuj tento TTRPG screenshot/y a vypl≈à data do zadan√©ho JSON sch√©matu. Extrahuj z obr√°zk≈Ø co nejv√≠ce textu do atribut≈Ø a popisu.";
        
        // Sestaven√≠ obsahu pro API (text + v≈°echny obr√°zky)
        const parts = [{ text: userQuery }];
        analysisImagesBase64.forEach(base64Data => {
            parts.push({
                inlineData: {
                    mimeType: "image/png",
                    data: base64Data
                }
            });
        });

        const payload = {
            contents: [{ role: "user", parts: parts }],
            systemInstruction: { parts: [{ text: systemPrompt }] },
            generationConfig: {
                responseMimeType: "application/json",
                responseSchema: responseSchema
            }
        };

        try {
            const API_URL = GEMINI_API_BASE_URL + apiKey;
            const MAX_RETRIES = 5;
            let response;
            for (let i = 0; i < MAX_RETRIES; i++) {
                try {
                    // Kl√≠ƒç je ji≈æ v API_URL, tak≈æe jen vol√°me fetch
                    response = await fetch(API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    
                    if (response.ok) break;

                } catch (e) {
                    if (i === MAX_RETRIES - 1) throw e;
                    await new Promise(resolve => setTimeout(resolve, Math.pow(2, i) * 1000));
                }
            }

            if (!response.ok) {
                const errorBody = await response.text();
                throw new Error(`API error: ${response.statusText}. Zkontrolujte kl√≠ƒç a limity. Chyba: ${errorBody}`);
            }

            const result = await response.json();
            
            const jsonText = result?.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!jsonText) {
                throw new Error("API nevr√°tilo strukturovan√° data.");
            }

            const data = JSON.parse(jsonText);
            updateFormFields(data);

        } catch (error) {
            console.error("Chyba p≈ôi anal√Ωze screenshotu:", error);
            const errorMessage = "Nepoda≈ôilo se analyzovat obr√°zek. Zkuste jin√Ω nebo zadejte data ruƒçnƒõ.";
            alert(`${errorMessage} Chyba: ${error.message.substring(0, 100)}...`);
        } finally {
            setLoading(false);
        }
    }
    
    function updateFormFields(data) {
        document.getElementById('cardTitle').value = data.title || '';
        document.getElementById('cardTranslation').value = data.translation || '';
        document.getElementById('cardDescription').value = data.description || '';
        document.getElementById('cardDescriptionCz').value = data.descriptionCz || ''; // NOV√â
        
        // NOV√Å LOGIKA: Nastaven√≠ typu karty (pokud je platn√Ω)
        if (data.cardType && CARD_TEMPLATES.hasOwnProperty(data.cardType.toUpperCase())) {
            cardTypeInput.value = data.cardType.toUpperCase();
        } else {
             // Fallback na Item, pokud se typ nepoda≈ô√≠ detekovat nebo je neplatn√Ω
             cardTypeInput.value = 'ITEM';
        }
        
        clearAttributes();
        
        if (data.attributes && Array.isArray(data.attributes)) {
            data.attributes.forEach(attr => {
                // VOL√ÅN√ç NOV√â JEDNOTN√â FUNKCE pro p≈ôid√°n√≠
                manageAttributes('add', null, attr.key, attr.value);
            });
        }
        
        updatePreview();
    }
    
    
    // --- Zalomen√≠ textu a form√°tov√°n√≠ (pro Popis) ---
    
    function drawFormattedText(ctx, rawText, x, y, maxWidth, lineHeight, fontBase, maxLines = Infinity) {
        let currentY = y;
        let linesDrawn = 0;
        
        // 1. P≈ôepracov√°n√≠ textu: nahrad√≠me \n\n za speci√°ln√≠ token [PB] (Paragraph Break) a \n za [LB]
        const processedText = rawText.replace(/\r/g, '').replace(/\n\n/g, ' [PB] ').replace(/\n/g, ' [LB] ');
        
        // 2. Rozdƒõlen√≠ podle form√°tov√°n√≠ a na≈°ich zlomov√Ωch token≈Ø
        let parts = processedText.split(/(\*\*.*?\*\*|\*.*?\*|\[PB\]|\[LB\]|\s+)/g).filter(p => p.length > 0);
        
        const getStyle = (isBold, isItalic) => `${isBold ? 'bold ' : ''}${isItalic ? 'italic ' : ''}${fontBase}px sans-serif`;
        
        let currentLineParts = []; // ƒå√°sti textu s r≈Øzn√Ωmi styly na aktu√°ln√≠m ≈ô√°dku
        
        const commitLine = (startNewLineWith = []) => {
            if (currentLineParts.length > 0) {
                if (linesDrawn < maxLines) {
                    let drawX = x;
                    
                    // Vykreslen√≠
                    currentLineParts.forEach(part => {
                        ctx.font = part.style;
                        ctx.fillText(part.text, drawX, currentY);
                        drawX += ctx.measureText(part.text).width;
                    });

                    currentY += lineHeight;
                    linesDrawn++;
                    currentLineParts = startNewLineWith;
                    return true;
                } else {
                    return false; // P≈ôeteƒçen√≠
                }
            }
            currentLineParts = startNewLineWith;
            return true;
        }

        let remainingParts = [];

        for (let i = 0; i < parts.length; i++) {
            let part = parts[i];
            
            // --- 1. Speci√°ln√≠ tokeny (PB, LB) ---
            if (part === '[PB]') {
                if (!commitLine()) { remainingParts = parts.slice(i); break; }
                if (linesDrawn < maxLines) {
                    currentY += lineHeight * 0.5; // Poloviƒçn√≠ mezera pro odstavce
                    linesDrawn++;
                } else { remainingParts = parts.slice(i); break; }
                continue;
            }
            
            if (part === '[LB]') {
                if (!commitLine()) { remainingParts = parts.slice(i); break; }
                continue;
            }

            // --- 2. Mezery (White space) ---
            if (part.match(/^\s+$/)) {
                 // Zpracov√°no n√≠≈æe ve slovƒõ, ignorujeme samostatn√© mezery
                continue;
            }


            // --- 3. Form√°tovan√Ω a norm√°ln√≠ text ---

            let isBold = part.startsWith('**') && part.endsWith('**');
            let isItalic = part.startsWith('*') && part.endsWith('*');
            
            let content = part;
            if (isBold) content = part.slice(2, -2);
            if (isItalic) content = part.slice(1, -1);
            
            let style = getStyle(isBold, isItalic);

            const words = content.split(/\s+/g).filter(w => w.length > 0);
            
            for (let j = 0; j < words.length; j++) {
                const word = words[j];
                
                // Urƒçen√≠, zda je pot≈ôeba mezera p≈ôed slovem
                const prefix = currentLineParts.length === 0 ? '' : ' ';
                const wordWithPrefix = prefix + word;

                // Spoƒç√≠tat aktu√°ln√≠ ≈°√≠≈ôku ≈ô√°dku + nov√© slovo
                let currentWidth = 0;
                currentLineParts.forEach(p => { 
                    ctx.font = p.style;
                    currentWidth += ctx.measureText(p.text).width; 
                });

                ctx.font = style;
                let testWidth = currentWidth + ctx.measureText(wordWithPrefix).width;
                
                if (testWidth > maxWidth) {
                    // Zalomen√≠ ≈ô√°dku (slovo se nevejde)
                    let remainingWords = words.slice(j);
                    
                    if (!commitLine()) { // Vykreslit aktu√°ln√≠ platn√Ω ≈ô√°dek
                        remainingParts = [word, ...remainingWords.slice(1)];
                        for (let k = i + 1; k < parts.length; k++) { remainingParts.push(parts[k]); }
                        break; // P≈ôeteƒçen√≠
                    }
                    
                    // Zaƒç√≠t nov√Ω ≈ô√°dek s aktu√°ln√≠m slovem
                    currentLineParts.push({ text: word, style: style });
                } else {
                    // Slovo se ve≈°lo
                    let lastPart = currentLineParts[currentLineParts.length - 1];
                    if (lastPart && lastPart.style === style) {
                        // FIX: Oprava pro plynul√© navazov√°n√≠ bez nadbyteƒçn√© mezery
                        const textToAdd = lastPart.text === '' ? word : (lastPart.text.endsWith(' ') ? word : ' ' + word);
                        lastPart.text += textToAdd;
                    } else {
                         // Prvn√≠ slovo na ≈ô√°dku nebo zmƒõna stylu
                        currentLineParts.push({ text: currentLineParts.length === 0 ? word : ' ' + word, style: style });
                    }
                }
            }
            if (remainingParts.length > 0) break;
        }
        
        // Vykreslen√≠ posledn√≠ho ≈ô√°dku
        if (currentLineParts.length > 0) {
            commitLine();
        }

        // Zrekonstruovat zb√Ωvaj√≠c√≠ text
        let remainingText = '';
        if (remainingParts.length > 0) {
            remainingText = remainingParts.join('');
            remainingText = remainingText.replace(/ \[PB\] /g, '\n\n').replace(/ \[LB\] /g, '\n').trim();
        }

        return { finalY: currentY, remainingText: remainingText };
    }


    
    // Funkce pro kreslen√≠ Atribut≈Ø 
    function drawAttributes(ctx, attributes, statsX, imageY, statsWidth) {
        let currentY = imageY;
        const lineHeight = 30;
        let lowestY = imageY;

        attributes.forEach(attr => {
            if (attr.key && attr.value) {
                // Toto je simulace v√Ωpoƒçtu v√Ω≈°ky, kter√° prob√≠h√° p≈ôi renderov√°n√≠!
                
                // Kl√≠ƒç (Tuƒçn√©)
                ctx.font = 'bold 20px sans-serif';
                const keyText = attr.key + ":";
                const keyWidth = ctx.measureText(keyText).width;
                
                const valueX = statsX + keyWidth + 5;
                const valueMaxWidth = statsWidth - (keyWidth + 5);

                // Hodnota (Norm√°ln√≠)
                ctx.font = '20px sans-serif';
                
                const words = attr.value.split(/\s+/);
                let line = '';
                let tempY = currentY;

                for(let n = 0; n < words.length; n++) {
                    const word = words[n];
                    const testLine = line + (line.length > 0 ? ' ' : '') + word;
                    const testWidth = ctx.measureText(testLine).width;

                    if (testWidth > valueMaxWidth && line.length > 0) {
                        // Vykresl√≠ p≈ôedchoz√≠ ≈ô√°dek
                        // ctx.fillText(line, valueX, tempY); // Vykreslovac√≠ k√≥d byl odebr√°n
                        tempY += lineHeight;
                        line = word;
                    } else {
                        line = testLine;
                    }
                    // Omezen√≠ na 3 ≈ô√°dky (pro atributy) - pouze pro v√Ωpoƒçet prostoru
                    if (tempY > currentY + (2 * lineHeight) + 5) {
                         // line += '...'; // Indik√°tor zkr√°cen√≠
                         // break; 
                    }
                }
                
                // Vykresl√≠ posledn√≠ ≈ô√°dek (nebo jedin√Ω ≈ô√°dek)
                if (line.length > 0) {
                    // ctx.fillText(line, valueX, tempY); // Vykreslovac√≠ k√≥d byl odebr√°n
                    tempY += lineHeight;
                }
                
                // Nyn√≠ provedeme skuteƒçn√© vykreslen√≠, abychom znali p≈ôesnou pozici
                ctx.font = 'bold 20px sans-serif';
                ctx.fillText(keyText, statsX, currentY);
                
                ctx.font = '20px sans-serif';
                ctx.fillStyle = '#000000';
                
                // Opakujeme logika vykreslen√≠ pro zji≈°tƒõn√≠ finalY
                let lineDraw = '';
                let finalY = currentY;

                for(let n = 0; n < words.length; n++) {
                    const word = words[n];
                    const testLine = lineDraw + (lineDraw.length > 0 ? ' ' : '') + word;
                    const testWidth = ctx.measureText(testLine).width;

                    if (testWidth > valueMaxWidth && lineDraw.length > 0) {
                        ctx.fillText(lineDraw, valueX, finalY);
                        finalY += lineHeight;
                        lineDraw = word;
                    } else {
                        lineDraw = testLine;
                    }
                    if (finalY > currentY + (2 * lineHeight) + 5) {
                         lineDraw += '...'; 
                         break; 
                    }
                }

                if (lineDraw.length > 0) {
                    ctx.fillText(lineDraw, valueX, finalY);
                    finalY += lineHeight;
                }
                
                currentY = finalY; // Posunout pro dal≈°√≠ atribut
                lowestY = Math.max(lowestY, currentY);
            }
        });
        return lowestY;
    }


    // NOV√Å POMOCN√Å FUNKCE: Vykreslen√≠ data
    function drawCreationDate(ctx) {
        const now = new Date();
        const dateString = now.toLocaleDateString('cs-CZ', { year: 'numeric', month: '2-digit', day: '2-digit' });
        const timeString = now.toLocaleTimeString('cs-CZ', { hour: '2-digit', minute: '2-digit' });
        
        // Zobrazen√≠ jazyka generov√°n√≠
        const langNote = printLanguage === 'CZ' ? 'CZ' : 'ENG';
        const creationText = `Vytvo≈ôeno: ${dateString} ${timeString} (${langNote})`; // P≈ôid√°na pozn√°mka o jazyku

        ctx.fillStyle = '#555555'; // Jemnƒõ ≈°ed√° barva
        ctx.font = '14px sans-serif'; // Mal√© p√≠smo
        ctx.textAlign = 'left';
        
        // Pozice v lev√©m doln√≠m rohu, kousek od okraje
        ctx.fillText(creationText, PADDING, BASE_CARD_H - PADDING + 5); 
        ctx.textAlign = 'left'; // Reset
    }


    function drawCardOnCanvas(ctx, cardData, targetWidth, targetHeight) {
        // Nastaven√≠ pl√°tna
        ctx.canvas.width = targetWidth;
        ctx.canvas.height = targetHeight;
        
        const cardSectionWidth = BASE_CARD_W - 2 * PADDING;
        const textPadding = 10;
        const descriptionLineHeight = 25; // Odstup ≈ô√°dk≈Ø popisu (vƒõt≈°√≠ ne≈æ velikost fontu pro ƒçitelnost)

        // 1. Vyplnƒõn√≠ pozad√≠ a r√°meƒçek cel√© karty
        // D≈ÆLE≈ΩIT√â: Pozad√≠ KARTY mus√≠ b√Ωt v≈ædy b√≠l√©, bez ohledu na Dark Mode
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(0, 0, targetWidth, targetHeight);
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 8; // JE≈†Tƒö VƒöT≈†√ç tlou≈°≈•ka r√°meƒçku
        
        const cardType = cardTypeInput.value;
        
        // Nastaven√≠ stylu ƒç√°ry r√°meƒçku podle typu karty (ZVƒöT≈†EN√â Mƒö≈ò√çTKO)
        if (cardType === 'SPELL') {
             ctx.setLineDash([18, 6, 6, 6]); // Vƒõt≈°√≠ vlnovit√Ω/fancy dash pattern
             ctx.lineDashOffset = 0;
        } else if (cardType === 'WEAPON') {
             ctx.setLineDash([40, 10]); // Vƒõt≈°√≠ ≈°piƒçat√Ω/dlouh√Ω dash pattern
             ctx.lineDashOffset = 0;
        } else if (cardType === 'EQUIPMENT') {
             ctx.setLineDash([20, 10]); // Vƒõt≈°√≠ ƒç√°rkovan√°
             ctx.lineDashOffset = 0;
        } else if (cardType === 'CONSUMABLE') {
             ctx.setLineDash([4, 4]); // Vƒõt≈°√≠ teƒçkovan√°
             ctx.lineDashOffset = 0;
        } else {
            ctx.setLineDash([]); // Pln√° ƒç√°ra pro Item/Other
        }

        ctx.strokeRect(0, 0, targetWidth, targetHeight);
        ctx.setLineDash([]); // Reset dash pro dal≈°√≠ kreslen√≠
        ctx.lineWidth = 2; // Zmen≈°en√≠ tlou≈°≈•ky pro vnit≈ôn√≠ prvky
        ctx.fillStyle = '#000000';
        ctx.textBaseline = 'top';

        // --- 1. N√°zev Karty (V≈ædy v 1. sekci) ---
        let titleText = cardData.title || '';
        if (cardData.translation) {
             titleText += ` (${cardData.translation})`;
        }
        
        const typeTextRaw = cardTypeInput.options[cardTypeInput.selectedIndex].text;
        const typeEmoji = TYPE_EMOJI[cardType] || '‚ùì';
        const fullTypeText = `${typeEmoji} ${typeTextRaw}`;
        
        const typeFontSize = 22;
        ctx.font = `bold ${typeFontSize}px sans-serif`;
        const typeWidth = ctx.measureText(fullTypeText).width;
        
        // Vypoƒçten√° ≈°√≠≈ôka pro n√°zev, aby se zabr√°nilo kolizi s typem (s mezerou PADDING)
        // NOV√Å LOGIKA: Ujist√≠me se, ≈æe n√°zev a typ maj√≠ dostatek m√≠sta
        const availableTitleWidth = cardSectionWidth - typeWidth - PADDING * 0.5;

        let titleFontSize = 40;
        let wrappedTitleLines = [titleText];

        // Zmen≈°en√≠ fontu, dokud se n√°zev nevejde na ≈°√≠≈ôku
        while (titleFontSize > 25) {
            ctx.font = `bold ${titleFontSize}px sans-serif`;
            const testWidth = ctx.measureText(titleText).width;
            if (testWidth <= availableTitleWidth) {
                break; // Ve≈°lo se na jeden ≈ô√°dek
            }
            titleFontSize -= 2;
        }
        
        // Zalomit text, pokud je i s mal√Ωm fontem p≈ô√≠li≈° dlouh√Ω
        if (titleFontSize <= 25) {
             wrappedTitleLines = wrapText(ctx, titleText, availableTitleWidth, `bold ${titleFontSize}px sans-serif`);
        }
        
        // V√Ωpoƒçet pozice pro n√°zev
        const titleY = PADDING;
        
        ctx.font = `bold ${titleFontSize}px sans-serif`;
        ctx.textAlign = 'left'; // Zarovn√°n√≠ n√°zvu doleva
        
        // Vykreslen√≠ n√°zvu (pouze prvn√≠ ≈ô√°dek pro jednoduchost, pokud se zalamuje)
        // Vykreslen√≠ pouze prvn√≠ho ≈ô√°dku pro n√°zev, aby nekolidoval s horn√≠ ƒç√°rou
        ctx.fillText(wrappedTitleLines[0], PADDING, titleY);

        // Vykreslen√≠ typu (prav√Ω horn√≠ roh)
        ctx.font = `bold ${typeFontSize}px sans-serif`; 
        ctx.textAlign = 'right';
        ctx.fillStyle = '#333333';
        ctx.fillText(fullTypeText, BASE_CARD_W - PADDING, PADDING + 5);
        ctx.textAlign = 'left'; // Reset

        // Horizont√°ln√≠ ƒç√°ra pod n√°zvem (v prvn√≠ sekci)
        ctx.beginPath();
        ctx.moveTo(PADDING, PADDING * 2.5);
        ctx.lineTo(BASE_CARD_W - PADDING, PADDING * 2.5);
        ctx.stroke();
        
        const middleSectionYStart = PADDING * 2.5 + 10;
        
        // --- 2. Rozdƒõlen√≠ Prost≈ôedn√≠ Sekce ---
        const imageX = PADDING;
        const imageY = middleSectionYStart;
        const statsX = imageX + IMAGE_SIZE + PADDING;
        const statsWidth = BASE_CARD_W - statsX - PADDING;

        // R√°meƒçek Obr√°zku
        ctx.lineWidth = 2;
        ctx.strokeRect(imageX, imageY, IMAGE_SIZE, IMAGE_SIZE);

        if (cardData.image) {
            // Pou≈æ√≠t pomocn√Ω canvas pro zaji≈°tƒõn√≠, ≈æe je obr√°zek perfektn√≠ ƒçtverec a nedoch√°z√≠ k deformaci
            const tempImgCanvas = document.createElement('canvas');
            const tempImgCtx = tempImgCanvas.getContext('2d');
            tempImgCanvas.width = IMAGE_SIZE;
            tempImgCanvas.height = IMAGE_SIZE;

            // V√Ωpoƒçet pomƒõru stran a o≈ô√≠znut√≠
            const img = cardData.image;
            const imgAspect = img.width / img.height;
            const canvasAspect = 1;

            let sourceX = 0;
            let sourceY = 0;
            let sourceWidth = img.width;
            let sourceHeight = img.height;

            if (imgAspect > canvasAspect) { // Obr√°zek je ≈°ir≈°√≠
                sourceWidth = img.height * canvasAspect;
                sourceX = (img.width - sourceWidth) / 2;
            } else if (imgAspect < canvasAspect) { // Obr√°zek je vy≈°≈°√≠
                sourceHeight = img.width / canvasAspect;
                sourceY = (img.height - sourceHeight) / 2;
            }
            
            tempImgCtx.drawImage(img, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, IMAGE_SIZE, IMAGE_SIZE);
            ctx.drawImage(tempImgCanvas, imageX, imageY);

        } else {
            ctx.font = '24px sans-serif';
            ctx.fillStyle = '#AAAAAA';
            ctx.fillText('Obr√°zek itemu', imageX + 80, imageY + 140);
            ctx.fillStyle = '#000000';
        }

        // Atributy
        // Spoƒç√≠t√°me fin√°ln√≠ Y pozici pro atributy (nejni≈æ≈°√≠ bod)
        const lowestYAttribute = drawAttributes(ctx, cardData.attributes, statsX, imageY, statsWidth);

        // --- 3. Popis (Roz≈°√≠≈ôen√≠) ---
        
        // D≈ÆLE≈ΩIT√Å OPRAVA: Popis zaƒç√≠n√° tam, kde konƒç√≠ buƒè obr√°zek, nebo atributy, + PADDING
        const descriptionY = Math.max(imageY + IMAGE_SIZE, lowestYAttribute) + PADDING;
        
        // V√Ωbƒõr popisu podle nastaven√©ho jazyka
        const rawText = (printLanguage === 'CZ' ? document.getElementById('cardDescriptionCz').value : cardData.description) || "";
        
        let remainingText = rawText;
        let currentDrawX = PADDING; // X-sou≈ôadnice pro vykreslen√≠ v aktu√°ln√≠ sekci
        let sectionIndex = 0;
        
        // Maxim√°ln√≠ ≈ô√°dky v prvn√≠ sekci (v√Ω≈°ka od descriptionY po doln√≠ padding)
        const heightFirstSection = BASE_CARD_H - descriptionY - PADDING;
        const maxLinesFirstSection = Math.max(0, Math.floor((heightFirstSection - (22 + textPadding)) / descriptionLineHeight)); // 22 je zhruba v√Ω≈°ka nadpisu
        
        // Maxim√°ln√≠ ≈ô√°dky v pln√© sekci (v√Ω≈°ka cel√© karty m√≠nus horn√≠/doln√≠ padding a nadpis)
        const maxLinesFullSection = Math.max(0, Math.floor((BASE_CARD_H - 2 * PADDING - (22 + textPadding)) / descriptionLineHeight));

        const descriptionTitle = "Popis:";

        while (remainingText.trim().length > 0) { 
            let maxLines;
            let currentYDescription;
            let sectionTopY;
            let sectionHeight;

            if (sectionIndex === 0) {
                // Prvn√≠ sekce
                maxLines = maxLinesFirstSection;
                sectionTopY = descriptionY;
                sectionHeight = heightFirstSection;
                currentYDescription = sectionTopY + textPadding + descriptionLineHeight;
            } else {
                // Roz≈°√≠≈ôen√© sekce
                maxLines = maxLinesFullSection;
                sectionTopY = PADDING;
                sectionHeight = BASE_CARD_H - 2 * PADDING;
                currentYDescription = sectionTopY + textPadding + descriptionLineHeight;
                
                // Oddƒõlovac√≠ ƒç√°ra pro sekce (p≈ôeru≈°ovan√°)
                ctx.save();
                ctx.strokeStyle = '#333333';
                ctx.setLineDash([15, 15]);
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(currentDrawX - PADDING, PADDING);
                ctx.lineTo(currentDrawX - PADDING, BASE_CARD_H - PADDING);
                ctx.stroke();
                ctx.restore();
            }
            
            // R√°meƒçek sekce
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#000000';
            ctx.strokeRect(currentDrawX, sectionTopY, cardSectionWidth, sectionHeight);
            
            // Nadpis sekce
            ctx.font = 'bold 22px sans-serif';
            ctx.fillText(descriptionTitle, currentDrawX + textPadding, sectionTopY + textPadding);
            
            // Vykreslen√≠ textu popisu
            const result = drawFormattedText(
                ctx, remainingText, 
                currentDrawX + textPadding, 
                currentYDescription, 
                cardSectionWidth - 2 * textPadding, 
                descriptionLineHeight, 
                18, // velikost fontu
                maxLines
            );
            
            remainingText = result.remainingText;
            
            sectionIndex++;
            currentDrawX += BASE_CARD_W;

            if (sectionIndex * BASE_CARD_W > targetWidth) break; // Ochrana proti nekoneƒçn√© smyƒçce
        }

        // Vykreslen√≠ data a ƒçasu (V_0.14)
        drawCreationDate(ctx);
    }
    
    // Pomocn√° funkce pro zalamov√°n√≠ textu, kdy≈æ je p≈ô√≠li≈° dlouh√Ω (pro n√°zev)
    function wrapText(ctx, text, maxWidth, fontStyle) {
        ctx.font = fontStyle;
        const words = text.split(' ');
        let line = '';
        const lines = [];

        for(let n = 0; n < words.length; n++) {
            const testLine = line + words[n] + ' ';
            const testWidth = ctx.measureText(testLine).width;
            if (testWidth > maxWidth && n > 0) {
                lines.push(line.trim());
                line = words[n] + ' ';
            } else {
                line = testLine;
            }
        }
        lines.push(line.trim());
        return lines;
    }


    window.updatePreview = function() {
        const title = document.getElementById('cardTitle').value;
        const translation = document.getElementById('cardTranslation').value;
        const description = document.getElementById('cardDescription').value;

        // Naƒçten√≠ a se≈ôazen√≠ atribut≈Ø
        const attributeElements = Array.from(document.querySelectorAll('#attributesContainer .attribute-row'));
        
        // Zde NEPROV√ÅD√çME AUTOMATICK√â ≈òAZEN√ç, ale pouze ƒçteme po≈ôad√≠, kter√© nastavil SortableJS
        const attributes = attributeElements.map(row => ({
            key: row.querySelector('.attr-key').value.trim(),
            value: row.querySelector('.attr-value').value.trim()
        })).filter(attr => attr.key && attr.value);
        
        // Odstranƒõn√≠ star√© logiky automatick√©ho ≈ôazen√≠:
        // attributes.sort((a, b) => { ... });

        currentCardData = {
            title,
            translation,
            description,
            attributes,
            image: itemImageObject
        };
        
        // --- Logika urƒçen√≠ pot≈ôebn√© ≈°√≠≈ôky karty (poƒçet sekc√≠) ---
        
        // Vyt√°hneme data pot≈ôebn√° pro simulaci
        const cardType = cardTypeInput.value;
        
        // 1. Zjistit, kolik m√≠sta zaberou horn√≠ sekce (N√°zev, Obr√°zek, Atributy)
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = BASE_CARD_W;
        tempCanvas.height = BASE_CARD_H;

        // Pou≈æijeme zjednodu≈°en√Ω v√Ωpoƒçet pozic pro zji≈°tƒõn√≠ m√≠sta
        const cardSectionWidth = BASE_CARD_W - 2 * PADDING;
        const textPadding = 10;
        const descriptionLineHeight = 25;
        const lineHeightAttr = 30;
        
        const middleSectionYStart = PADDING * 2.5 + 10;
        const imageY = middleSectionYStart;
        const statsX = PADDING + IMAGE_SIZE + PADDING;
        const statsWidth = BASE_CARD_W - statsX - PADDING;

        let currentY = imageY;
        currentCardData.attributes.forEach(attr => {
            if (attr.key && attr.value) {
                 // Tato ƒç√°st se mus√≠ shodovat s logikou v drawAttributes!
                 if (currentY + lineHeightAttr > imageY + IMAGE_SIZE * 3) return; // Ochrana proti nekoneƒçnu
                 
                 // Simulace v√Ωpoƒçtu v√Ω≈°ky pro attribute
                 tempCtx.font = 'bold 20px sans-serif';
                 const keyWidth = tempCtx.measureText(attr.key + ":").width;
                 const valueMaxWidth = statsWidth - (keyWidth + 5);

                 tempCtx.font = '20px sans-serif';
                 const words = attr.value.split(/\s+/);
                 let line = '';
                 let finalY = currentY;

                 for(let n = 0; n < words.length; n++) {
                     const word = words[n];
                     const testLine = line + (line.length > 0 ? ' ' : '') + word;
                     const testWidth = tempCtx.measureText(testLine).width;

                     if (testWidth > valueMaxWidth && line.length > 0) {
                         finalY += lineHeightAttr;
                         line = word;
                     } else {
                         line = testLine;
                     }
                     // Toto je jen simulace, neomezujeme
                 }
                 if (line.length > 0) {
                     finalY += lineHeightAttr;
                 }
                 currentY = finalY;
            }
        });
        
        // D≈ÆLE≈ΩIT√Å OPRAVA V√ùPOƒåTU: Pot≈ôebujeme zjistit, kde zaƒç√≠n√° popis
        const descriptionY = Math.max(imageY + IMAGE_SIZE, currentY) + PADDING;
        
        const heightFirstSection = BASE_CARD_H - descriptionY - PADDING;
        const maxLinesFirstSection = Math.max(0, Math.floor((heightFirstSection - (22 + textPadding)) / descriptionLineHeight));
        
        // Pou≈æijeme text popisu podle vybran√©ho jazyka
        const textToSimulate = (printLanguage === 'CZ' ? document.getElementById('cardDescriptionCz').value : description) || "";

        let requiredSections = 1;
        let tempRemainingText = textToSimulate;

        if (maxLinesFirstSection > 0) {
            // Simulace kreslen√≠ textu na prvn√≠ sekci
            const resultFirst = drawFormattedText(tempCtx, tempRemainingText, 0, 0, cardSectionWidth - 2 * textPadding, descriptionLineHeight, 18, maxLinesFirstSection);
            tempRemainingText = resultFirst.remainingText;
        }


        // Simulace v√Ωpoƒçtu pro dal≈°√≠ sekce (full height)
        const maxLinesFullSection = Math.max(0, Math.floor((BASE_CARD_H - 2 * PADDING - (22 + textPadding)) / descriptionLineHeight));
        
        while (tempRemainingText.trim().length > 0) {
            requiredSections++;
            if (maxLinesFullSection > 0) {
                const resultFull = drawFormattedText(tempCtx, tempRemainingText, 0, 0, cardSectionWidth - 2 * textPadding, descriptionLineHeight, 18, maxLinesFullSection);
                tempRemainingText = resultFull.remainingText;
            } else {
                break; // Nem√°me m√≠sto ani v pln√© sekci
            }
            
            if (requiredSections > 10) break; // Z bezpeƒçnostn√≠ch d≈Øvod≈Ø
        }
        
        requiredSections = Math.max(requiredSections, 1);

        const finalWidth = requiredSections * BASE_CARD_W;
        
        // Nastaven√≠ velikosti pro n√°hled (≈°k√°lov√°n√≠)
        const scaleFactor = 3; 
        canvas.style.width = `${finalWidth / scaleFactor}px`;
        canvas.style.height = `${BASE_CARD_H / scaleFactor}px`;
        canvas.style.aspectRatio = `${finalWidth} / ${BASE_CARD_H}`; // Zaji≈°tƒõn√≠ spr√°vn√©ho pomƒõru stran
        
        // Vykreslen√≠ na n√°hledov√Ω canvas
        drawCardOnCanvas(ctx, currentCardData, finalWidth, BASE_CARD_H);
    }
    
    // --- MODAL A ZOOM FUNKCE ---
    
    const zoomModal = document.getElementById('zoomModal');
    const zoomCanvas = document.getElementById('zoomCanvas');

    window.showZoomModal = function() {
        const finalWidth = ctx.canvas.width;
        const finalHeight = ctx.canvas.height;

        zoomCanvas.width = finalWidth;
        zoomCanvas.height = finalHeight;

        // Kop√≠rov√°n√≠ obsahu
        const image = ctx.getImageData(0, 0, finalWidth, finalHeight);
        zoomCanvas.getContext('2d').putImageData(image, 0, 0);

        // Nastaven√≠ CSS velikosti pro zobrazen√≠ v modalu (omez√≠me na viewport)
        zoomCanvas.style.width = 'auto'; 
        zoomCanvas.style.height = 'auto'; 
        zoomCanvas.style.maxWidth = '90vw';
        zoomCanvas.style.maxHeight = '90vh';
        
        zoomModal.classList.remove('hidden');
    }

    window.closeZoomModal = function() {
        zoomModal.classList.add('hidden');
    }

    // --- FUNKCE PRO EXPORT DAT ---
    
    // Z√≠sk√°n√≠ n√°zvu souboru (spoleƒçn√° logika pro PDF a JSON)
    function getExportFilename(extension) {
        const cardType = cardTypeInput.value.toUpperCase();
        // Nahrazen√≠ nepovolen√Ωch znak≈Ø podtr≈æ√≠tky
        const cardName = (currentCardData.title || 'karta').replace(/[^a-zA-Z0-9-()]/g, '_');
        
        let cardLevel = 'N_A';
        const levelAttr = currentCardData.attributes.find(attr => attr.key.toUpperCase() === 'LEVEL' || attr.key.toUpperCase() === '√öROVE≈á');
        if (levelAttr) {
            // Vyƒçist√≠me level pro n√°zev souboru
            cardLevel = levelAttr.value.replace(/[^a-zA-Z0-9]/g, '');
            if (cardLevel === '') cardLevel = 'N_A';
        }
        
        const sectionCount = Math.round(ctx.canvas.width / BASE_CARD_W);
        const dimensions = `${CARD_W_MM}x${CARD_H_MM}mm_x${sectionCount}`;
        
        // Form√°t: [typ]_[level]___[nazev]___[(rozmer)].[extenze]
        return `${cardType}_${cardLevel}___${cardName}___(${dimensions}).${extension}`;
    }

    window.exportPDF = function() {
        if (!currentCardData.title) {
            alert("Vypl≈àte pros√≠m N√°zev karty.");
            return;
        }

        const filename = getExportFilename('pdf');
        
        // Z√≠sk√°n√≠ fin√°ln√≠ch rozmƒõr≈Ø z preview canvas (kter√© byly dynamicky nastaveny)
        const targetWidth = ctx.canvas.width;
        const targetHeight = ctx.canvas.height;
        hiddenCanvas.width = targetWidth;
        hiddenCanvas.height = targetHeight;

        // P≈ôekreslen√≠ do skryt√©ho canvasu s plnou kvalitou
        drawCardOnCanvas(hiddenCtx, currentCardData, targetWidth, targetHeight);
        
        const imageData = hiddenCanvas.toDataURL('image/png');

        // V√Ωpoƒçet rozmƒõr≈Ø v mm
        const finalWidthMM = targetWidth / PX_PER_MM;
        const finalHeightMM = targetHeight / PX_PER_MM;

        const { jsPDF } = window.jspdf;
        // P≈ôid√°me malou rezervu (2mm) pro o≈ôez a nastaven√≠ form√°tu
        const doc = new jsPDF({
            orientation: finalWidthMM > finalHeightMM ? 'l' : 'p',
            unit: 'mm',
            format: [finalWidthMM + 2, finalHeightMM + 2] 
        });
        
        // P≈ôid√°n√≠ obr√°zku (karty) s 1mm okrajem
        doc.addImage(imageData, 'PNG', 1, 1, finalWidthMM, finalHeightMM, '', 'FAST');

        // Kreslen√≠ o≈ôezov√Ωch znaƒçek a linie slo≈æen√≠
        doc.setDrawColor(0);
        doc.setLineWidth(0.1);
        doc.rect(1, 1, finalWidthMM, finalHeightMM); // Tenk√Ω r√°meƒçek pro o≈ôez (bleed)
        
        const sectionCount = Math.round(ctx.canvas.width / BASE_CARD_W);
        if (sectionCount > 1) {
            // Znaƒçky pro slo≈æen√≠/p≈ôelo≈æen√≠ (ka≈æd√Ωch 63mm)
            for (let i = 1; i < sectionCount; i++) {
                const foldX = i * CARD_W_MM + 1; // +1mm kv≈Øli okraji
                // Kr√°tk√© ƒç√°ry naho≈ôe a dole
                doc.line(foldX, 1, foldX, 4);
                doc.line(foldX, finalHeightMM - 2, foldX, finalHeightMM + 1);
            }
        }
        
        doc.save(filename);
    }
    
    // NOV√Å FUNKCE: Export dat do JSON souboru
    window.exportJSON = function() {
        if (!currentCardData.title) {
            alert("Vypl≈àte pros√≠m N√°zev karty.");
            return;
        }

        // Z√≠sk√°n√≠ ƒçist√Ωch dat z formul√°≈ôe
        const attributes = Array.from(document.querySelectorAll('#attributesContainer .attribute-row'))
            .map(row => ({
                key: row.querySelector('.attr-key').value.trim(),
                value: row.querySelector('.attr-value').value.trim()
            }))
            .filter(attr => attr.key && attr.value);

        const dataToExport = {
            title: document.getElementById('cardTitle').value,
            translation: document.getElementById('cardTranslation').value,
            cardType: cardTypeInput.value,
            description: document.getElementById('cardDescription').value,
            descriptionCz: document.getElementById('cardDescriptionCz').value, // NOV√â
            attributes: attributes
        };
        
        const filename = getExportFilename('json');
        const jsonText = JSON.stringify(dataToExport, null, 2);
        
        const blob = new Blob([jsonText], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    // Inicializace SortableJS
    function initSortable() {
        Sortable.create(attributesContainer, {
            animation: 150,
            ghostClass: 'bg-indigo-200',
            handle: '.attribute-row', // Cel√Ω ≈ô√°dek je nyn√≠ √∫chyt
            onEnd: function (evt) {
                // Po p≈ôesunut√≠ se aktualizuje n√°hled a tedy i po≈ôad√≠ atribut≈Ø
                updatePreview(); 
            }
        });
    }

    // Inicializace
    window.onload = function() {
        // --- Dark Mode Inicializace ---
        if (localStorage.getItem('theme') === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
            body.classList.add('dark');
        }
        updateThemeIcons();
        
        // Inicializujeme API kl√≠ƒç z localStorage, pokud existuje (pokud Canvas API kl√≠ƒç nen√≠ k dispozici)
        if (!CANVAS_API_KEY) {
            const storedApiKey = localStorage.getItem('geminiApiKey');
            if (storedApiKey) {
                geminiApiKeyInput.value = storedApiKey;
            }
            // Zobrazit vstup pro lok√°ln√≠ kl√≠ƒç, pokud nen√≠ dostupn√Ω Canvas kl√≠ƒç
            document.getElementById('apiKeyHint').style.display = 'none'; 
            geminiApiKeyInput.disabled = false;
        } else {
             // Skr√Ωt tip/vstup pro lok√°ln√≠ kl√≠ƒç, pokud je dostupn√Ω Canvas kl√≠ƒç
             document.getElementById('apiKeyHint').style.display = 'inline';
             geminiApiKeyInput.disabled = true;
             geminiApiKeyInput.placeholder = "Pou≈æ√≠v√° se kl√≠ƒç Canvasu. Nen√≠ pot≈ôeba zad√°vat.";
        }
        
        initSortable(); // Inicializace Drag & Drop
        updateAnalyzeButtonState(); // Zkontroluje stav tlaƒç√≠tka na zaƒç√°tku
        
        // Nastav√≠ v√Ωchoz√≠ jazyk a aktualizuje vzhled tlaƒç√≠tek
        const storedLang = localStorage.getItem('printLanguage') || 'ENG';
        setPrintLanguage(storedLang); 

        updatePreview();
    };

    // Naslouch√°n√≠ zmƒõn√°m v hlavn√≠ch pol√≠ch
    document.getElementById('cardTitle').addEventListener('input', updatePreview);
    document.getElementById('cardTranslation').addEventListener('input', updatePreview);
    document.getElementById('cardDescription').addEventListener('input', updatePreview);
    document.getElementById('cardDescriptionCz').addEventListener('input', updatePreview); // NOV√â
    document.getElementById('cardType').addEventListener('change', updatePreview); // P≈ôid√°no pro typ karty
    // Naslouch√°n√≠ zmƒõn√°m v atributech (zachyt√≠ v≈°echny zmƒõny v inputech uvnit≈ô kontejneru)
    document.getElementById('attributesContainer').addEventListener('input', updatePreview);

    // Naslouch√°n√≠ zmƒõn√°m v API kl√≠ƒçi (ukl√°d√° se jen, pokud nepou≈æ√≠v√°me kl√≠ƒç Canvasu)
    geminiApiKeyInput.addEventListener('input', function() {
        if (!CANVAS_API_KEY) {
            localStorage.setItem('geminiApiKey', geminiApiKeyInput.value.trim());
        }
        updateAnalyzeButtonState();
    });
</script>

</body>
</html>
